#  the script takes an orthogroup fasta file generated by orthofinder as input. The original script 
#  would generate this file from a csv list, but since it is already generated by orthofinder
#  I will skip this step and go immediately to the alignment.

#  The original script offers different alignment software options, but I will only implement clustal-OMEGA.

##	INPUT
#	(+)An orthogroup multifasta file generated by orthofinder. (only use orthogroups exclusively
#       consisting of 1-to-1 orthologs!)
#	(+)Corresponding DNA and Protein sequences for each ortholog, in FASTA format. 
#       If a directory is given then the script will assume it contains complete cds fastas and extract the required sequences by sequence header itself

##	OUTPUT
#	Up to four files will be generated for each desired ID:
#	(+)<orthogroup_ID>.fa_extracted_cds.fna	| A multiple-sequence FASTA file of the Nucleotide orthologs. Not aligned.
#	(+)orthogroup.prot_aln.fasta			| An alignment file of the protein orthologs, FASTA format.
#	(+)orthogroup.pal2nal.paml		    	| A codon-based nucleotide ortholog alignment, for use with PAML
#	(+)[2YN|2NG].dNdS   	    	    	| pairwise dN/dS values calculated by yn00 or codeml respectively

##  REQUIREMENTS:
#   (+) stuff on uppmax:
#       module load bioinfo-tools clustalo/1.2.4 biopython/1.80-py3.10.8 paml/4.10.7
#       (+) emboss          | to translate the nucleotide sequences into proteinfasta with transeq, on uppmax it's emboss/6.6.0
#       (+) BioPython       | (The original script uses BioPerl since it's in perl), can be loaded as uppmax module
#       (+) CLUSTAL-Omega   | (For multiple-sequence alignments), can be loaded as uppmax module
#       (+) PAML            | can be loaded as uppmax module
#       (+) FastTree        | uppmax module FastTree/2.2-GCCcore-13.3.0
#   (+) stuff not on uppmax:
#       (+) pal2nal         | (not available on uppmax, get from github and set binary path with command line flag)
#                           | /proj/naiss2023-6-65/Lila/beetle_genomes/pal2nal.v14/pal2nal.pl

#	For USAGE please run without any options or specifying flag -h or --help


##  TESTING:
#   test case: 1-to-1 orthogroup
#       /proj/naiss2023-6-65/Lila/beetle_genomes/Orthofinder_beetles/OrthoFinder/Results_May30/Orthogroup_Sequences/OG0006976.fa
#   species cds directory
#       /proj/naiss2023-6-65/Milena/gene_family_analysis/cds_native_annotations
#   command
#       python3 calculate_orthogroup_dNdS.py --orthogroup /proj/naiss2023-6-65/Lila/beetle_genomes/Orthofinder_beetles/OrthoFinder/Results_May30/Orthogroup_Sequences/OG0006980.fa --cds /proj/naiss2023-6-65/Milena/gene_family_analysis/cds_native_annotations --pal2nalbin /proj/naiss2023-6-65/Lila/beetle_genomes/pal2nal.v14/pal2nal.pl --verbose --overwrite




import argparse
from Bio import SeqIO, AlignIO
from Bio.SeqRecord import SeqRecord
import os
import subprocess
import re
import time


def parse_args():
    # Create the parser
    program_description = """
A script to calculate the dN/dS ratio between two sequences in a fasta file.
The individual steps consist of:
(1) make a proteinfasta by translating the cds fasta
(2) make a codon-based multi-sequence alignment 
(3) run yn00 or codeml and calculate the pairwise dNdS ratio
    NOTE: specify a path to either a codeml (--codemlbin) or yn00 (--yn00bin) executeable to specify which one the model should run. You have to give a path to where the actual executeable is so that the config file can be retrieved
"""
    parser = argparse.ArgumentParser(description=program_description)

    # Add the arguments
    parser.add_argument('--cds', required=True, help="coding sequence (aminoacid) multifasta containing the two sequences between which you would like to calculate the dNdS ratio")
    parser.add_argument('-o', '--outdir', type=str, help='Directory where the output_file is stored, default: working directory, make new dir named like filename from cds input (truncated at last point to remove file extension)')
    
    parser.add_argument('--pal2nalbin', type=str, help="Absolute path to an executeable to run pal2nal, default: ./pal2nal.pl")
    parser.add_argument('--pal2naloptions', type=str, help="command line options for pal2nal, default: -output paml -nogap -nomismatch")
    
    parser.add_argument('--clustalbin', type=str, help="path to the clustal-omega executeable if it is not default clustalo. not necessary if the uppmax module is loaded with: module load clustalo/1.2.4")
    parser.add_argument('--alnoptions', type=str, help="optional alignment options, empty by default")
    
    parser.add_argument('--fasttreebin', type=str, help="Absolute path to an executeable to run fasttree, default: FastTree")

    paml = parser.add_mutually_exclusive_group(required=True)
    paml.add_argument('--codeml', action='store_true', help="run codeml (specify path to executeable in --codemlbin)")
    paml.add_argument('--yn00', action='store_true', help="run yn00 (specify path to executeable in --yn00bin)")

    paml_bin = parser.add_mutually_exclusive_group(required=False)
    paml_bin.add_argument('--codemlbin', type=str, help="path to the codeml executeable")
    paml_bin.add_argument('--yn00bin', type=str, help="path to the yn00 executeable")
    parser.add_argument('--codemlmodel', type=str, help="codeml model that should be run, default 1 ('model' in the config, see paml documentation for details")

    parser.add_argument('--verbose', action='store_true', help="enable verbose mode")
    parser.add_argument('--overwrite', action='store_true', help="overwrite existing output files with default names from previous runs")

    # Parse the arguments
    args = parser.parse_args()

    # set default values for non-obligatory arguments
    if not args.outdir:
        args.outdir = args.cds.split("/")[-1].split(".")[0]+"_dNdS"
        # print(f"no output directory provided, default directory created: {args.outdir}")
    if not args.pal2nalbin:
        args.pal2nalbin = "./pal2nal.pl" # assumes pal2nal is in the current directory
    if not args.pal2naloptions:
        args.pal2naloptions = "-output clustal -nogap -nomismatch" # Originally: -output clustal -nogap -nomismatch"  
    if not args.alnoptions:
        args.alnoptions = ""
    if not args.clustalbin:
        args.clustalbin = "clustalo"
    if not args.fasttreebin:
        args.fasttreebin = "FastTree"
    if not args.codemlbin:
        args.codemlbin = "codeml"
    if not args.yn00bin:
        args.yn00bin = "yn00"
    if not args.codemlmodel:
        args.codemlmodel = "1"
    # if not args.verbose:
    #     args.verbose=False
    
    if args.outdir[-1]!="/": # if outdir does not include a trailing "/", add it
        args.outdir=args.outdir+"/"

    return args


def adjust_phylip_spacing(input_file, output_file):
    """
    adjust the spacing in each line to be correct for the following steps
    """
    new_lines = []
    with open(input_file, "r") as infile:
        lines = infile.readlines()
        for line in lines:
            if line.strip() and not line.startswith(" "):
                name = line[:10]
                sequence = line[10:]
                # outfile.write(f"{name:10}  {sequence}\n")
                new_lines.append(f"{name:10}  {sequence}\n")
            else:
                # outfile.write(line)
                new_lines.append(line)
    with open(output_file, "w") as outfile:
        outfile.writelines(new_lines)


def truncate_leaf_names(newick_tree):
    """
    if the tree is needed, modify the leaf names to only be the first 10 characters to mach with the pal2nal alignment file
    the treefile also needs to be a tree structure file (see page 15 of the paml documentation)
    """
    # Regular expression to match leaf names
    pattern = re.compile(r'([a-zA-Z_@0-9.-]+):')

    def split_at_second_occurrence(s, char="_"): # split the gene string at the second occurence of "_" to get only the species name
        second_occurrence = s.find(char, 2) # start after the first occurence of "_"
        string = s[second_occurrence+1:]
        return string
    
    def truncate_match(match):
        leaf_name = match.group(1)
        leaf_name = split_at_second_occurrence(leaf_name) # split the first iteration of the species name that orthofiner adds (i think? no idea where else it would come from) to be sure that everything matches
        truncated_name = leaf_name[:10]
        return truncated_name + ':'
    
    # Substitute each leaf name with its truncated version
    modified_tree = pattern.sub(truncate_match, newick_tree)

    # get the number of species in the tree (number of matches to the pattern)
    num_species = len(list(pattern.finditer(newick_tree)))
    return modified_tree, num_species


def make_cds_fasta(proteinfasta, cds_list, verbose):

    nucleotide_fasta = []
    record_found = False

    print(f"generating CDS fasta file from {proteinfasta}")

    start_time = time.time()
    # go through all protein names in the proteinfasta
    for OG_record in SeqIO.parse(proteinfasta, "fasta"):
        record_found=False

        # remove the trailing "_1" that the orthofinder protein ID names have
        if OG_record.id[-2:] =="_1":
            OG_record.id = OG_record.id[:-2]
        if verbose:
                print(f"\tcurrently seqrching: {OG_record.id}")
    
        # find which protein header matches the current OG_record.id
        for species in cds_list:
            if verbose:
                species_print = species.split("/")[-1]
                print(f"\t\tcurrently reading: {species_print}")
            for species_cds in SeqIO.parse(species, "fasta"):

                # orthofinder replaces "|" with "_", so I have to replace it here too or I won't find matches 
                if "|" in species_cds.id:
                    header = species_cds.id
                    header = header.replace("|", "_")
                    species_cds.id = header

                # find matching species_cds.id in complete nucleotide cds files
                if species_cds.id in OG_record.id or OG_record.id in species_cds.id:
                    # print(species_cds.id)
                    species_cds.id = OG_record.id.split(" ")[0]
                    nucleotide_fasta.append(species_cds)
                    record_found=True
                    break # don't continue if a match is found. It seems like it works pretty well with the unique gene names, so breaking here to cut down on runtime instead of including a warning for double-matches seems worth it
            if record_found==True:
                if verbose:
                    print(f"\t\tfound! {species_cds.id}")
                break
                # break 
        if record_found==False:
            print(f'WARNING: no matching cds record found for protein record {OG_record.id} in orthogroup file {proteinfasta}.')
    
    end_time = time.time()
    passed_time = end_time - start_time
    if verbose:
        print(f"making the nucleotide fasta file took {passed_time:.2f} seconds, or {passed_time/60.0:.2f} minutes")
    return(nucleotide_fasta)



def is_file_non_empty(file_path):
    # Check if the file exists
    if os.path.isfile(file_path):
        # Get the size of the file
        if os.path.getsize(file_path) > 0:
            return True
    return False


def make_proteinfasta(cds_fasta_path, outdir):
    """
    make a proteinfasta file in the output directory that is translated from cds_Fasta_path
    """
    prot_name = f"{outdir}protein_sequences.faa"
    prot_records = []
    for seq_record in SeqIO.parse(cds_fasta_path, "fasta"):
        seq_record.seq = seq_record.seq.translate(cds=True)
        prot_records.append(seq_record)
    SeqIO.write(prot_records, prot_name, "fasta")
    return prot_name


def calculate_dNdS(dN_filepath, dS_filepath, dNdS_filepath):
    with open(dN_filepath, "r") as dN_file, open(dS_filepath, "r") as dS_file, open(dNdS_filepath, "w") as dNdS_file:
    
        dN_values = [dN_values.split() for dN_values in dN_file.readlines() if len(dN_values.split())>0][1:] # the if condition makes sure the line is not empty. Also cut out the first line that only contains the number of species
        dS_values = [dS_values.split() for dS_values in dS_file.readlines() if len(dS_values.split())>0][1:]
        
        if verbose:
            print(f"dN/dS values for {outdir_path}")
        for i in range(len(dN_values)): # loop through all subsequent lines
            
            species = dN_values[i][0]
            dN = [float(i) for i in dN_values[i][1:]]
            dS = [float(i) for i in dS_values[i][1:]]
            dN_dS_ratio_line = "\t".join([str(dN[j]/dS[j]) if dS[j]!= 0.0 else "NaN" for j in range(len(dN)) ])
            dN_dS_ratio_line = "\t".join([species, dN_dS_ratio_line])

            if verbose:
                print(dN_dS_ratio_line)
            dNdS_file.write(dN_dS_ratio_line+"\n")

        if verbose:
            print(f"dN/dS values were written to file {outdir_path}{dNdS_filepath}")




if __name__ == '__main__':
    
    ### define variables from command line input

    args=parse_args()
    outdir_path = args.outdir
    cds_path = args.cds

    clustal_bin = args.clustalbin
    pal2nal_bin = args.pal2nalbin
    pal2nal_options = args.pal2naloptions
    aln_options = args.alnoptions

    fasttree_bin = args.fasttreebin

    verbose = args.verbose
    overwrite = args.overwrite

    run_yn00 = args.yn00
    yn00_bin = args.yn00bin
    run_codeml =args.codeml
    codeml_bin = args.codemlbin
    

    print()
    
    topdir = os.getcwd() # working directory above all the output directories

    # take care of output directory

    if not os.path.exists(outdir_path):
        print(f"The specified output directory is created at: {outdir_path}")
        os.makedirs(outdir_path)
    elif overwrite:
        print(f"The output directory {outdir_path} already exists and overwrite mode is enabled, therefore existing output files are overwritten")
    elif overwrite:
        print(f"The output directory {outdir_path} already exists, but overwrite mode is disabled so existing outfiles are used")


    print(f"\n====================== {outdir_path} ======================")
    print()
    
    ############################
    ### make multifasta file ###
    ############################

    # check if the cds input is a directory (contains cds fasta complete for all species of interest)
    # or a file (cds multifasta directly corresponding to the proteinfasta orthogroup input file)

    if os.path.isfile(cds_path) and os.path.getsize(cds_path) > 0:
        if verbose:
            print(f"'{cds_path}' found!")
        # list and print files in directory
    elif os.path.isfile(cds_path):
        raise RuntimeError(f"'{cds_path}' not found!")
    elif os.path.getsize(cds_path) == 0:
        raise RuntimeError(f"'{cds_path}' is empty!")

    ## make proteinfasta
    prot_path = make_proteinfasta(cds_path, outdir_path)
    if verbose:
        print(f"protein sequences translated: {prot_path}")

    
    ###########################################
    ### do the alignment with clustal-omega ###
    ###########################################

    clustal_outfile = f"{outdir_path}prot_aln.fasta"

    # check if an alignment file exists from a previous run
    if not os.path.exists(clustal_outfile) or overwrite:
        if verbose:
            print("\n *  starting clustal-OMEGA:\n")
            if overwrite:
                print(f"overwrite mode enabled --> overwriting existing file {clustal_outfile}")
    
        clustal_omega_command = f"{clustal_bin} {aln_options} -i {prot_path} -o {clustal_outfile}"
        if overwrite:
            clustal_omega_command = f"{clustal_bin} {aln_options} -i {prot_path} -o {clustal_outfile} --force"

        start_time = time.time()
        print("command: "+clustal_omega_command)
        end_time = time.time()
        if verbose:
            passed_time = end_time - start_time
            if verbose:
                print(f"making the alignment took {passed_time:.2f} seconds, or {passed_time/60.0:.2f} minutes")
                
        result = subprocess.run(clustal_omega_command, shell = True, capture_output=True, text=True)
        # Check if the command was successful
        if result.returncode == 0:
            if verbose:
                print("clustal-OMEGA ran successfully.")
                print(result.stdout)
        elif is_file_non_empty(clustal_outfile)==False:
            raise RuntimeError(f"clustal-OMEGA outfile: {clustal_outfile} is empty")
        else:
            wd = os.getcwd()
            filesize = os.path.getsize(clustal_outfile)
            raise RuntimeError(f"clustal-OMEGA failed in directory {wd}")

    else:
        print(f"{clustal_outfile} exists already, using existing file for next steps.")


    #####################################
    ############ run pal2nal ############
    #####################################

    pal2nal_alignment = f"{clustal_outfile}.paml"
    pal2nal_command = f"{pal2nal_bin} {clustal_outfile} {cds_path} {pal2nal_options} > {pal2nal_alignment}"

    if verbose:
        print(" *  running pal2nal (codon based alignment)\n")
    print("command: "+pal2nal_command)
    result = subprocess.run(pal2nal_command, shell = True, capture_output=True, text=True)
    # Check if the command was successful
    if result.returncode == 0:
        if verbose:
            print(f"pal2nal ran successfully")
    else:
        raise RuntimeError(f"pal2nal failed!\n{result.stderr}")
    if os.path.getsize(pal2nal_alignment) == 0:
        raise RuntimeError(f"pal2nal failed, {pal2nal_alignment} is empty")

    # Read the Clustal file
    alignment = AlignIO.read(f"{pal2nal_alignment}", "clustal")

    # Write the alignment in PHYLIP format
    # for details about sequential and interleaved phylip formats, see
    # paml documentation p. 11
    AlignIO.write(alignment, f"{pal2nal_alignment}", "phylip-sequential")

    # adjust spacing 
    adjust_phylip_spacing(f"{pal2nal_alignment}", f"{pal2nal_alignment}")

    if verbose:
        print(f"done, adjusted spacing in {pal2nal_alignment}")

    print()
    

    ###########################################
    ############# run PAML (yn00) #############
    ###########################################

    ########## make tree

    tree_outfile = f"{outdir_path}tree.tre"
    fasttree_command = f"{fasttree_bin} {clustal_outfile} > {tree_outfile}"
    result = subprocess.run(fasttree_command, shell = True, capture_output=True, text=True)
    # Check if the command was successful
    if result.returncode == 0:
        if verbose:
            print(f" *  FastTree ran successfully")
    else:
        raise RuntimeError(f"FastTree failed! command: \n{fasttree_command}")
    if os.path.getsize(tree_outfile) == 0:
        raise RuntimeError(f"{tree_outfile} is empty!")

    ##########

    if run_yn00: 
        if verbose:
            print(" *  set up and run paml (yn00)\n")
        
        # copy the yn00 config file 

        # on UPPMAX: yn00_config_source = "/sw/bioinfo/paml/4.10.7/rackham/examples/yn00.ctl"
        yn00_config_source = yn00_bin.split("src")[0]
        yn00_config_source = f"{yn00_config_source}examples/yn00.ctl"
        if not os.path.isfile(yn00_config_source):
            yn00_config_source = yn00_bin.split("bin")[0]
            yn00_config_source = f"{yn00_config_source}examples/yn00.ctl"
        if not os.path.isfile(yn00_config_source):
            raise RuntimeError(f"yn00 config file not found in expected location {yn00_config_source}!")

        yn00_config = f"{outdir_path}yn00.ctl"
        copy_command = f"cp {yn00_config_source} {yn00_config}"
        os.system(copy_command)
        if verbose:
            print(copy_command)
        
        ## modify the config file
        # The files are all in the same output folder as the config which is also used in the rest of this, 
        # therefore I will not use absolute filepaths

        #!! careful with the paths here, they are relative to the contig file and not the working directory!
        # -> variables that exclude the directory
        pal2nal_filename = pal2nal_alignment.split("/")[-1]
        yn00_outfile = f"{outdir_path}yn00.out"

        yn00_settings_dict = {"seqfile" : f"{pal2nal_filename}",
                            "outfile" : "yn00.out"}

        if verbose:
            print()
            print("setting up paml config file with the following parameters:")
            # print(paml_settings_dict)

        modified_lines = []
        with open(yn00_config, "r") as config:
            lines = config.readlines()
            for line in lines: # go through all lines
                for key, value in yn00_settings_dict.items():
                    if key+" = " in line: # check if to-modify variable is in line
                        line = key+" = "+value+"\n" # make new line and overwrite the old one
                        if verbose:
                            print("\t"+line.split("\n")[0]) # remove the newline character for printing so it looks nicer
                modified_lines.append(line)
        with open(yn00_config, "w") as yn00:
            yn00.writelines(modified_lines)

        if verbose:
            print(f"done modifying {yn00_config}")
            print()

        ## set up paml run
        ###!!
        os.chdir(outdir_path) 
        ###!!
        wdir = os.getcwd()

        # run paml from the output directory, since the files referenced in yn00.ctl don't have absolut paths and are just filenames
        paml_command = f"{yn00_bin} > yn00.log"
        if verbose:
            print("running yn00 from this directory: ")
            print(wdir)
        print(f"command: {paml_command}")

        # run paml and catch errors in case it goes wrong
        try:
            os.system(paml_command)
        except Exception as e:
            print(f"An error occurred while running yn00: {e}")
        if os.path.getsize("yn00.out") == 0:
            raise RuntimeError(f"{yn00_outfile} is empty!")
        if verbose:
            print(f"\ndone with yn00, outfile: {wdir}/yn00.out")
    
        ### calculate pairwise dNdS from 2YN.dN and 2YN.dS
        # stay in the working directory for the orthogroup

        dN_filepath = "2YN.dN"
        dS_filepath = "2YN.dS"
        dNdS_filepath = "2YN.dNdS"

        if is_file_non_empty(dN_filepath) and is_file_non_empty(dS_filepath):
            if verbose:
                print(f"\t -  calcualte dN/dS ratio:")

            calculate_dNdS(dN_filepath, dS_filepath, dNdS_filepath)
        else:
            # if it didn't work try codeml
            print(f"\n==> yn00 did not produce {dN_filepath} or {dS_filepath}, try codeml!")
            run_codeml = True

    os.chdir(topdir)


    if run_codeml: # if the 2YN files are empty/nonexistent, either because it didn't work or because --codeml was specified and it wasn't run

    ###########################################
    ############ run PAML (codeml) ############
    ###########################################
        if verbose:
            print(f"\n *  run codeml")

        ######### modify the newick tree to work with codeml
        tree_modified = tree_outfile.replace(".tre", "_10chr_leafnames.tre")

        with open(f"{tree_outfile}", 'r') as f, open(f"{tree_modified}", 'w') as o:
            if verbose:
                print(f"\t - modify the newick tree {tree_modified} so that each leaf consists only of a 10 character string")
            newick_tree = f.read()
            mod_tree, num_species = truncate_leaf_names(newick_tree)
            o.write(f"\t{num_species} 1\n") # the numbers are first the number of species and then the number of trees (which is a format specification but i hardcoded 1 since i always have only one tree)
            o.write(mod_tree)
            
        if verbose:
            print(f"\t\t--> Modified tree saved to {tree_modified}\n")

        #########

        ## try to run codeml properly with the tree.

        #   from the paml documentation in the yn00 section p. 41:
        #       " We recommend that you use the ML method (runmode= 2, CodonFreq = 2 in codeml.ctl)
        #         as much as possible even for pairwise sequence comparison. "
        #   since we have a tree, I will still use runmode 0, since 2 is automatic (and does not require a tree)

        tree_loc = tree_modified.split("/")[-1]
        pal2nal_loc = pal2nal_alignment.split("/")[-1]
        codeml_settings_dict = {"seqfile" : f"{pal2nal_loc}", 
                        "treefile" : f"{tree_loc}",  ## TODO the treefile has one more iteration of the species name than the seqfile? not sure if that's a problem, it still runs but maybe it does some stuff?
                        "outfile" : "codeml.out", 
                        "model" : args.codemlmodel, # default model is 1
                        "verbose" : "1",
                        "seqtype" : "1",
                        #"runmode" : "2", # 2 is an automatic run mode, the default is 0 which is a user generated tree
                        "CodonFreq" : "2" 
                        } 
        

        # os.chdir(topdir)
        ###!!
        os.chdir(outdir_path) 
        ###!!
        # copy the codeml config file into the folder
        # codeml_config_source = "/sw/bioinfo/paml/4.10.7/rackham/examples/codeml.ctl"
        codeml_config_source = codeml_bin.split("bin")[0]
        codeml_config_source = f"{codeml_config_source}examples/codeml.ctl"
        if not os.path.isfile(codeml_config_source):
            codeml_config_source = codeml_bin.split("src")[0]
            codeml_config_source = f"{codeml_config_source}examples/codeml.ctl"
        if not os.path.isfile(codeml_config_source):
            raise RuntimeError(f"codeml config file not found in expected location {codeml_config_source}!")

        codeml_config = f"codeml.ctl"
        copy_command = f"cp {codeml_config_source} {codeml_config}"

        os.system(copy_command)
        if verbose:
            print(f"\t - setup config file\n\t\tcopy from source: {copy_command}\n\t\tmodify config file:")
        

        ## modify the codeml config file:

        modified_lines = []        
        with open(codeml_config, "r") as codeml:
            lines = codeml.readlines()
            for line in lines: # go through all lines
                for key, value in codeml_settings_dict.items():
                    if key+" = " in line: # check if to-modify variable is in line
                    #if key in line: # check if to-modify variable is in line
                        line = key+" = "+value+"\n" # make new line and overwrite the old one
                        if verbose:
                            print("\t"+line.split("\n")[0]) # remove the newline character for printing so it looks nicer
                modified_lines.append(line)
        with open(codeml_config, "w") as yn00:
            yn00.writelines(modified_lines)

        if verbose:
            print(f"\t\t--> done modifying {codeml_config}")
            print()

        codeml_command = f"{codeml_bin} > codeml.log"
        if verbose:
            print(f"\t - running: {codeml_command}")
        
        start_time = time.time()
        os.system(codeml_command) ## this does not run on the login node on uppmax! Nothing happens, you have to run it as sbatch even for testing
        end_time = time.time()
        
        if verbose:
            print("\t\tdone with codeml!")
            passed_time = end_time - start_time
            if verbose:
                print(f"\t - codeml took {passed_time:.2f} seconds, or {passed_time/60.0:.2f} minutes")
        else:
            print(f"command: {codeml_command}")

        #### done with codeml, calculate dNdS based on that:

        dN_filepath = "2NG.dN"
        dS_filepath = "2NG.dS"
        dNdS_filepath = "2NG.dNdS"

        
        if is_file_non_empty(dN_filepath) and is_file_non_empty(dS_filepath):
            if verbose:
                print(f"\n *  calcualte dN/dS ratio:")

            calculate_dNdS(dN_filepath, dS_filepath, dNdS_filepath)
        print(f"outfile: {dNdS_filepath}")
        
        os.chdir(topdir)


